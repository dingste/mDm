{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"abstract/","title":"Abstract","text":"<p>The mDm programming language stands as a testament to the ongoing evolution and innovation within the software development sphere, seeking to bridge the gaps identified by shortcomings in current programming paradigms and languages. Highlighting the core principles of mDm, this language aims to tackle the challenges of structured programming, modularity, and expressiveness, integrating essential feedback mechanisms and narrowing the modeling gap that lies between the problem domain and the software solution. More so, mDm allows for structuring any problem into smaller, manageable sub-problems. Conversely, partial solutions can be aggregated into a cohesive whole.</p> <p>The incorporation of feedback mechanisms and the focus on minimizing the modeling gap through expressive syntax and constructs in mDm demonstrate an acknowledgment of the need for programming languages and environments to align more closely with the conceptualization and design of systems. This vision aligns with that of Krasemann, wherein the development process is augmented by tools that offer immediate feedback, enable direct manipulation of program structures, and facilitate a seamless transition between design and implementation phases.</p> <p>By advocating a structured approach to programming through the IPO model and direct sequences (dSeq), mDm not only streamlines the software development process but also fosters clarity and predictability in program behavior. Adhering to the principles of structured programming ensures that developers can craft more maintainable, readable, and robust applications, addressing core deficiencies identified by Floyd and others concerning the necessity for a broad spectrum of paradigms supported by programming languages.</p> <p>Furthermore, the utilization of macros, groupings, and the scope operator ::: in mDm promotes a degree of modularity and reusability crucial for contemporary software development practices. This methodology is in line with the vision of establishing a comprehensive language workbench in which domain-specific languages (DSLs) and meta-programming are pivotal in customizing the programming environment to meet the specific requirements of the problem domain.</p> <p>In conclusion, mDm embodies a progressive stance on programming language design, aiming to encapsulate the principles and vision for future programming paradigms and environments. By addressing the limitations of existing languages, offering mechanisms for modularity and expressiveness, and underscoring the significance of feedback and reduced modeling gaps, mDm provides a preview into the prospective future of software development. As we persist in our exploration and innovation within the programming language realm, mDm represents a significant stride towards achieving a more expressive and efficient programming environment. ([source] May 7, 2006, Requirements for a Programming Language, H. Krasemann)</p>"},{"location":"introduction/","title":"Introduction","text":"<p>Programming languages are foundational to software development, translating human logic into commands that machines can execute. mDm is introduced as a language based on the structured paradigm of input, processing, and output (IPO) modules, similar to the computation by classic von Neumann architecture. This three-part structure is termed dSeq (direct sequence). The architecture promotes a clear separation of concerns, modular design, and improved readability, thereby setting the stage for efficient and error-reduced coding practices. While no existing programming language perfectly aligns with the unique combination of features and paradigms mDm proposes, many languages do include elements that align with its fundamental principles. The design of mDm represents a synthesis of structured programming, type safety, modularity, and a distinct IPO model, drawing inspiration from both functional and system programming languages to meet contemporary software development challenges. Specifically, its modularity allows for a more explicit approach to addressing every problem expressed.</p> <p>Document under:                                  Apache License                            Version 2.0, January 2004                         http://www.apache.org/licenses/</p>"},{"location":"advanced-topics/dynamic-memory-management/","title":"Dynamic Memory Management","text":"<p>By allowing data to be stored either directly or through address references (indirectly), the system can dynamically decide how and where to allocate memory. For small data values that fit directly next to the dNib, memory space can be conserved since no additional references are required. Larger data structures or those that can grow dynamically, such as lists or strings, utilize indirect referencing, allowing memory allocation to be tailored to needs and in variable sizes.</p>"},{"location":"advanced-topics/efficient-memory-usage/","title":"Efficient Memory Usage","text":"<p>Separating metadata (dNib) from data enables more efficient use of memory. Since the dNib carries information about the data type and structure, memory can be precisely allocated according to the requirements of data allocation, leading to minimized waste of memory space. For example, empty or undefined areas can be easily identified and reused or overwritten without the need for extensive garbage collection processes.</p>"},{"location":"advanced-topics/explicitly-defining-a-variable-type/","title":"Explicitly Defining a Variable Type","text":"<p>This adaptation emphasizes mDm's innovative features and principles, such as dynamic memory management, the importance of explicit over implicit in programming, and the structuring of complex data types, fostering a clear, modular, and expressive programming environment.</p>"},{"location":"advanced-topics/implicit-is-wack/","title":"Implicit is Wack!","text":"<p>Emphasizing explicit definitions over implicit assumptions, this principle in mDm aims to eliminate uncertainties in data type interpretation and usage. mDm's approach to programming language design is ambitious and innovative, incorporating structured programming principles with modern features like macros, groupings, and advanced data handling. Let's explore the detailed syntax description and how type declarations for common data types are structured in mDm, highlighting its unique paradigm focused on input, processing, and output (dSeqs).</p> <pre><code>Type Annotations in dSeqs: When defining dSeqs, type annotations can explicitly declare the types of inputs, processing steps, and outputs. This clarity supports mDm's objective of making each dSeq self-contained and understandable.\nType Safety in Modular Design: mDm's modular design, emphasizing modules, packages, and namespaces, leverages type safety to ensure correct usage of interfaces between different parts of the program and appropriate sharing or isolation of data.\nType Inference for Ease of Use: Type inference in mDm could be particularly beneficial for writing concise and expressive code, especially when complex operations or algorithms allow for clear type inference from the context.\n</code></pre>"},{"location":"advanced-topics/improvement-of-memory-access-times/","title":"Improvement of Memory Access Times","text":"<p>By efficiently distributing data according to their use and size in memory, memory access times can be optimized. Directly referenced data offer fast access for small amounts of data, while indirectly referenced structures provide the flexibility to efficiently manage large and complex data.</p> <pre><code>(address, dNib::Type, content), defineData, usage\n</code></pre>"},{"location":"advanced-topics/optimization-for-specific-use-cases/","title":"Optimization for Specific Use Cases","text":"<p>Through flexible handling of memory allocation, applications can make specific optimizations, such as by pre-allocating and reusing frequently used data structures. This reduces the need for constant allocations and releases of memory, improving the overall performance of the application.</p>"},{"location":"advanced-topics/simplification-of-memory-release/","title":"Simplification of Memory Release","text":"<p>The clear marking of data end and type by the dNib facilitates the release of memory. When a data block is no longer needed, the system can examine the dNib to determine how and where the data are stored (directly or indirectly) and release the corresponding memory. This is particularly useful in environments with manual memory management but can also support automated garbage collection methods.</p>"},{"location":"advanced-topics/support-for-complex-data-structures/","title":"Support for Complex Data Structures","text":"<p>The use of address references enables the creation of complex, linked data structures, such as linked lists, trees, and graphs, without the need to hold the entire structure in a continuous memory block. This makes it easier to allocate memory for new elements since only the memory for the element itself and not for the entire structure needs to be allocated. Additionally, structure elements can be distributed in memory, optimizing memory usage.</p>"},{"location":"advanced-topics/unsort/","title":"Unsort","text":""},{"location":"advanced-topics/unsort/#dynamische-speicherverwaltung","title":"Dynamische Speicherverwaltung","text":"<p>Durch die M\u00f6glichkeit, Daten entweder direkt oder \u00fcber Adressverweise (indirekt) zu speichern, kann das System dynamisch entscheiden, wie und wo Speicher alloziert wird. F\u00fcr kleine Datenwerte, die direkt neben dem dNib passen, kann Speicherplatz eingespart werden, da keine zus\u00e4tzlichen Verweise n\u00f6tig sind. Gr\u00f6\u00dfere Datenstrukturen oder solche, die dynamisch wachsen k\u00f6nnen, wie Listen oder Strings, nutzen indirekte Referenzierung, wodurch die Allokation von Speicher nach Bedarf und in variablen Gr\u00f6\u00dfen m\u00f6glich wird.</p>"},{"location":"advanced-topics/unsort/#effiziente-nutzung-des-speichers","title":"Effiziente Nutzung des Speichers","text":"<p>Die Trennung von Metadaten (dNib) und Daten erm\u00f6glicht eine effizientere Nutzung des Speichers. Da das dNib Informationen \u00fcber den Datentyp und die Struktur tr\u00e4gt, kann der Speicher genau nach den Erfordernissen der Datenallokation angepasst werden, was zu einer Minimierung von verschwendetem Speicherplatz f\u00fchrt. Beispielsweise k\u00f6nnen leere oder undefinierte Bereiche leicht identifiziert und wiederverwendet oder \u00fcberschrieben werden, ohne umfangreiche Garbage Collection durchf\u00fchren zu m\u00fcssen.</p>"},{"location":"advanced-topics/unsort/#vereinfachung-der-speicherfreigabe","title":"Vereinfachung der Speicherfreigabe","text":"<p>Die klare Kennzeichnung von Datenende und Typ durch das dNib erleichtert die Freigabe von Speicher. Wenn ein Datenblock nicht mehr ben\u00f6tigt wird, kann das System das dNib untersuchen, um zu bestimmen, wie und wo die Daten gespeichert sind (direkt oder indirekt), und den entsprechenden Speicher freigeben. Dies ist besonders n\u00fctzlich in Umgebungen mit manueller Speicherverwaltung, kann aber auch automatisierte Garbage Collection-Verfahren unterst\u00fctzen.</p>"},{"location":"advanced-topics/unsort/#unterstutzung-fur-komplexe-datenstrukturen","title":"Unterst\u00fctzung f\u00fcr komplexe Datenstrukturen","text":"<p>Die Verwendung von Adressverweisen erm\u00f6glicht die Erstellung komplexer, verkn\u00fcpfter Datenstrukturen, wie verkettete Listen, B\u00e4ume und Graphen, ohne die Notwendigkeit, die gesamte Struktur in einem kontinuierlichen Speicherblock zu halten. Dies erleichtert die Allokation von Speicher f\u00fcr neue Elemente, da nur der Speicher f\u00fcr das Element selbst und nicht f\u00fcr die gesamte Struktur allokiert werden muss. Zudem k\u00f6nnen Strukturelemente im Speicher verteilt werden, was die Speichernutzung optimiert.</p>"},{"location":"advanced-topics/unsort/#optimierung-fur-spezifische-anwendungsfalle","title":"Optimierung f\u00fcr spezifische Anwendungsf\u00e4lle","text":"<p>Durch die flexible Handhabung der Speicherallokation k\u00f6nnen Anwendungen spezifische Optimierungen vornehmen, beispielsweise indem h\u00e4ufig genutzte Datenstrukturen im Voraus alloziert und wiederverwendet werden. Dies reduziert die Notwendigkeit f\u00fcr st\u00e4ndige Allokationen und Freigaben von Speicher und verbessert die Gesamtleistung der Anwendung.</p>"},{"location":"advanced-topics/unsort/#verbesserung-der-speicherzugriffszeiten","title":"Verbesserung der Speicherzugriffszeiten","text":"<p>Indem Daten entsprechend ihrer Nutzung und Gr\u00f6\u00dfe effizient im Speicher verteilt werden, k\u00f6nnen Speicherzugriffszeiten optimiert werden. Direkt referenzierte Daten bieten schnellen Zugriff f\u00fcr kleine Datenmengen, w\u00e4hrend indirekt referenzierte Strukturen die Flexibilit\u00e4t bieten, gro\u00dfe und komplexe Daten effizient zu verwalten.</p> <ul> <li>mDm Example: Using dNib for data interpretation.   <code>mDm   (address, dNib::Type, content), defineData, usage</code></li> </ul>"},{"location":"advanced-topics/unsort/#implicit-is-wack","title":"Implicit is Wack!","text":"<p>Promoting explicit definitions over implicit assumptions, this principle in mDm aims to eliminate uncertainties in data type interpretation and usage. Eine detaillierte Erl\u00e4uterung des Typsystems von mDm, einschlie\u00dflich der unterst\u00fctzten Datentypen (wie Integer, Float, String, Listen, usw.), sowie Regeln f\u00fcr Typkonversion und Typinferenz. mDm's approach to programming language design is ambitious and innovative, drawing inspiration from structured programming principles and incorporating modern features like macros, groupings, and advanced data handling. Let's dive into the detailed syntax description and how type declarations for common data types are structured in mDm, reflecting on its distinctive paradigm that focuses on input, processing, and output (dSeq (direct sequence)s).</p> <ul> <li>Type Annotations in dSeq (direct sequence)s: In defining dSeq (direct sequence)s, type annotations can be used to explicitly declare the types of inputs, processing steps, and outputs. This clarity supports mDm's goal of making each dSeq (direct sequence) self-contained and understandable.</li> <li>Type Safety in Modular Design: The modular design of mDm, with its emphasis on modules, packages, and namespaces, would leverage type safety to ensure that interfaces between different parts of the program are correctly used and that data is appropriately shared or isolated.</li> <li>Type Inference for Ease of Use: Type inference would be particularly useful in making mDm code concise and expressive, especially when writing complex operations or algorithms where the types can be clearly inferred from the context.</li> <li></li> <li>mDm Example: Explicitly defining a variable type.   <code>mDm   (42, int, myVariable)</code></li> </ul>"},{"location":"advanced-topics/unsort/#legacy-compare","title":"Legacy Compare","text":""},{"location":"advanced-topics/unsort/#function-body","title":"Function body","text":"<p>Das Kapitel \u00fcber Funktionsk\u00f6rper in der mDm Programmiersprache illustriert die Art und Weise, wie Funktionen definiert und verwendet werden. In mDm wird jede Funktion oder dState (direkte Sequenz) als eine Struktur mit drei Hauptteilen betrachtet: Eingabe, Verarbeitung und Ausgabe. Dies folgt dem grundlegenden Prinzip von mDm, das Programmieren durch klare und strukturierte Abl\u00e4ufe zu vereinfachen.</p> <p>Die Definition einer Funktion in mDm folgt dem Schema:</p> <pre><code>FUNKTIONSPARAMETER,(\n    FUNKTIONSK\u00d6RPER\n),FUNKTIONSNAME\n</code></pre> <p>Dies entspricht dem Modell: Eingabe, Verarbeitung, Ausgabe. An der Speicherstelle <code>FUNKTIONSNAME</code> liegt das Ergebnis, also der Returnwert der Funktion, als letzter Verarbeitungsschritt an.  Ein einfaches Beispiel k\u00f6nnte eine Funktion sein, die zwei Zahlen addiert, gleich einer Dekleration:</p> <p>math</p> <p>In diesem Beispiel sind <code>a</code> und <code>b</code> die Eingabeparameter f\u00fcr die Funktion. Der Funktionsk\u00f6rper f\u00fchrt die Addition durch (<code>a + b</code>), und das Ergebnis dieser Verarbeitung wird unter dem Funktionsnamen <code>addiere</code> abgelegt. Um eine solche Funktion aufzurufen und das Ergebnis zu nutzen, k\u00f6nnte der Code wie folgt aussehen, gleich einer implementierung: Hier werden <code>5</code> und <code>3</code> als Eingabeparameter an die Funktion <code>addiere</code> \u00fcbergeben. Das Ergebnis der Addition wird in der Variablen <code>ergebnis</code> gespeichert.</p>"},{"location":"advanced-topics/unsort/#importing","title":"Importing","text":"<p>mDm streamlines external dependencies and modular programming with straightforward import syntax. The language simplifies external dependencies and modular programming through its import constructs, allowing for the inclusion of libraries and modules with a straightforward syntax. This approach to dependency management streamlines code organization and reuse.</p> <p>mDm defines clear rules for importing and exporting code elements to manage dependencies and ensure that only the necessary parts of a module or package are exposed to the rest of the program.</p> <ul> <li> <p>Importing: When a module or package needs to use functions, classes, or other elements defined elsewhere, it can import them using mDm's import statement. The import mechanism specifies how and which components of a module or package can be accessed by others, promoting loose coupling and high cohesion within and across modules.</p> </li> <li> <p>To import a module or specific functionalities from a module, mDm uses syntax that might look similar to <code>(iostream; string), import, IO</code>, where <code>iostream</code> and <code>string</code> are the modules or functionalities being imported, and <code>IO</code> is an optional alias to refer to the imported entities.</p> </li> <li> <p>Exporting: Modules and packages in mDm specify what functionalities they make available to other parts of the program or to other programs. Exporting is controlled through specific statements that declare which dSeq (direct sequence)s, functions, or classes can be used externally. This ensures that internal details of a module or package can remain hidden, exposing only a defined interface to the outside world.</p> </li> <li> <p>An export statement in mDm clearly marks which components are intended for external use, potentially using syntax. existing of dSeq (direct sequence)s in same memory region, they are inherent exported, cause of all dSeq (direct sequence)s are public in that memory. outside of own memory region, the dSeq (direct sequence)s arn't resolved.</p> </li> <li> <p>mDm Example: Importing a module.</p> </li> </ul>"},{"location":"advanced-topics/unsort/#declaring-variables-types","title":"Declaring (Variables / Types)","text":"<p>Variable and type declarations in mDm follow a structured syntax, enhancing clarity and modularity. Eine detaillierte Erl\u00e4uterung des Typsystems von mDm, einschlie\u00dflich der unterst\u00fctzten Datentypen (wie Integer, Float, String, Listen, usw.), sowie Regeln f\u00fcr Typkonversion und Typinferenz. mDm's approach to programming language design is ambitious and innovative, drawing inspiration from structured programming principles and incorporating modern features like macros, groupings, and advanced data handling. Let's dive into the detailed syntax description and how type declarations for common data types are structured in mDm, reflecting on its distinctive paradigm that focuses on input, processing, and output (dSeq (direct sequence)s).</p> <ul> <li>Type Annotations in dSeq (direct sequence)s: In defining dSeq (direct sequence)s, type annotations can be used to explicitly declare the types of inputs, processing steps, and outputs. This clarity supports mDm's goal of making each dSeq (direct sequence) self-contained and understandable.</li> <li>Type Safety in Modular Design: The modular design of mDm, with its emphasis on modules, packages, and namespaces, would leverage type safety to ensure that interfaces between different parts of the program are correctly used and that data is appropriately shared or isolated.</li> <li>Type Inference for Ease of Use: Type inference would be particularly useful in making mDm code concise and expressive, especially when writing complex operations or algorithms where the types can be clearly inferred from the context.</li> </ul> <p>The declaration of common data types in mDm emphasizes the language's structured and modular design. Here are examples of how various data types can be declared:</p> <p>Type example</p> <p>Um auf Basis des dNib-Konzepts in mDm weitere Datentypen wie char, string, numerical, fraction, und list zu deklarieren, wobei jedem Wert ein dNib vorangestellt ist, kann man die Speicherstruktur und -interpretation entsprechend planen. Angesichts einer 32-Bit-Architektur, bei der nach Abzug des dNib 28 Bit f\u00fcr den eigentlichen Wert verbleiben, ergeben sich interessante M\u00f6glichkeiten f\u00fcr die Darstellung und Verwaltung dieser Typen. Hier ein \u00dcberblick \u00fcber eine m\u00f6gliche Implementierung dieser Datentypen unter Ber\u00fccksichtigung des dNib: Char</p> <pre><code>Ein char k\u00f6nnte direkt in den verbleibenden 28 Bit gespeichert werden, wobei das dNib Informationen \u00fcber den Typ (z.B. dass es sich um ein Zeichen handelt) und m\u00f6glicherweise \u00fcber die Codierung enth\u00e4lt. Bei Bedarf k\u00f6nnten Zeichen, die mehr als 28 Bit erfordern, \u00fcber mehrere Speicherstellen verteilt werden, mit einem fortlaufenden dNib, das anzeigt, dass das Zeichen \u00fcber die erste Speicherstelle hinausgeht.\n</code></pre>"},{"location":"advanced-topics/unsort/#string","title":"String","text":"<pre><code>Ein string w\u00fcrde aus einer Sequenz von char bestehen, wobei jedes Zeichen sein eigenes dNib besitzt. Das EndOfTyp-dNib am Ende des Strings signalisiert das Ende der Zeichenkette. F\u00fcr l\u00e4ngere Texte, die mehrere Speicherstellen ben\u00f6tigen, w\u00fcrden fortlaufende dNibs die Zugeh\u00f6rigkeit zum gleichen String anzeigen, bis ein dNib mit der Markierung EndOfType das Ende kennzeichnet.\n</code></pre>"},{"location":"advanced-topics/unsort/#numerical","title":"Numerical","text":"<pre><code>Numerische Typen (int, float etc.) w\u00fcrden \u00e4hnlich behandelt. Ein numerical k\u00f6nnte in 28 Bit oder \u00fcber mehrere Speicherstellen f\u00fcr gr\u00f6\u00dfere Genauigkeit oder Wertebereiche verteilt werden. Das dNib w\u00fcrde hierbei den Typ (z.B. Ganzzahl oder Flie\u00dfkommazahl) und das Ende der Zahl (EndOfType) markieren.\n</code></pre>"},{"location":"advanced-topics/unsort/#fraction","title":"Fraction","text":"<pre><code>Eine fraction (Bruch) k\u00f6nnte als zwei numerical Werte dargestellt werden, einer f\u00fcr den Z\u00e4hler und einer f\u00fcr den Nenner, jeweils mit eigenen dNibs. Ein drittes dNib k\u00f6nnte das Ende der fraction markieren und somit die beiden Teile als zusammengeh\u00f6rig definieren.\n</code></pre>"},{"location":"advanced-topics/unsort/#list","title":"List","text":"<pre><code>Eine list w\u00e4re eine Sequenz von Werten (z.B. char, numerical, andere lists), wobei jedes Element durch ein dNib gekennzeichnet ist. Das Ende einer Liste w\u00fcrde durch ein EndOfType-dNib gekennzeichnet. F\u00fcr verschachtelte Listen w\u00fcrde jedes Listenelement sein eigenes dNib haben, das den Beginn einer neuen Liste markiert, gefolgt von den Elementen dieser Unternliste, bis ein EndOfType-dNib das Ende anzeigt.\n</code></pre>"},{"location":"advanced-topics/unsort/#complex-types-struct-like","title":"Complex Types (Struct-like)","text":"<p>mDm allows for the definition of complex data types, akin to structs in C or objects in other object-oriented languages. This can be done by defining a sequence of elements, each with its own type and identifier, grouped together:</p> <p>This syntax showcases mDm's unique approach to programming language design, focusing on clarity, modularity, and the seamless integration of structured programming principles. It's designed to encourage developers to think about the flow of data through their programs, making the development process more intuitive and aligned with computational theory.</p>"},{"location":"advanced-topics/unsort/#defining-complex-data-types","title":"Defining Complex Data Types","text":"<p>mDm supports the definition of complex data types through a sequence of elements, each characterized by its own IPO schema. This feature exemplifies the language's strong typing and modular design principles, enabling precise and clear data modeling. zusammen gesetzte datentypen, d.h. sie werden in mDm durch () gebildet, siehe Complex Types:</p> <pre><code>((1,int,zaehler);(2,int, nenner)), fracture, afracture\n</code></pre> <pre><code>((_,char,_);(2,int, length)), string, astring\n</code></pre> <p>gleiches gilt f\u00fcr: dSeq (direct sequence)s, list, ...</p> <p>In the conceptual framework of mDm, type safety and type inference are critical features designed to enhance the language's reliability, readability, and ease of use. These features align with mDm's overarching goals of structured programming, modularity, and clarity.</p>"},{"location":"advanced-topics/unsort/#counting","title":"Counting","text":"<p>Demonstrates handling numeric operations and counters in mDm.</p> <ul> <li>mDm Example: Incrementing a counter.   <code>mDm   (counter; 1), add, counter</code></li> </ul>"},{"location":"advanced-topics/unsort/#operating","title":"Operating","text":"<p>Showcases basic arithmetic and logical operations within the structured syntax of mDm. mDm's capability to perform arithmetic operations is shown in this straightforward example, demonstrating the language's approach to basic mathematical tasks.</p> <p>By specifying the inputs, operation, and output, mDm maintains clarity and precision in expressing arithmetic, adhering to its structured programming model.</p>"},{"location":"advanced-topics/unsort/#conditions","title":"Conditions","text":"<p>Conditional statements in mDm allow for decision-making based on dynamic data. zur weiteren verarbeitung m\u00fcssen bedingungen erf\u00fcllt sein. sind sie nicht erf\u00fcllt, sind sie f\u00fcr dSeq (direct sequence)s nicht wahr. mit dem '' undefined macro k\u00f6nnen sie weiter verarbeitet werden, mit undefinierten verhalten. weitere verarbeitungsschritte sind notwendig, um '' auf wahren inhalt zu pr\u00fcfen und f\u00fcr die weitere verarbeitung entscheidbar zu machen. Implementing conditional logic in mDm, this example handles decision-making based on user input, showcasing the language's support for dynamic and conditional operations.</p> <p>Control structures, including conditional statements, are represented in mDm using a similar dSeq (direct sequence) syntax, which integrates seamlessly with the language's structured programming approach. Conditionals are defined by specifying the condition as part of the input, the evaluation as the process, and the consequent action as the output.</p> <p>This snippet illustrates a conditional check on <code>userInput</code> to determine if it is greater than or equal to 18, and prints \"Adult\" if the condition is true.</p> <p>The conditional operation <code>if &gt;=</code> demonstrates mDm's ability to execute different paths based on runtime conditions, a crucial feature for responsive programs. mDm handles loops, control structures, iteration, and recursion within its unique framework of dSeq (direct sequence)s and the IPO (Input, Processing, Output) model, adhering to its structured approach to programming. The language's design principles facilitate clear and concise representation of these constructs, emphasizing modularity and predictability. </p> <p>Condition examples</p>"},{"location":"advanced-topics/unsort/#iteration","title":"Iteration","text":"<p>Iteration over collections like lists or arrays is handled through dSeq (direct sequence) constructs that allow for accessing and manipulating elements in a sequence. mDm's syntax for iteration is designed to work with its structured approach, enabling developers to specify the operation to be performed on each element of the collection.</p> <pre><code>/// Variable\n0, int, counter\n(1;2;3;4;5), list, myList\n\n/// Iteration Construct\n(counter; size(myList)), while &lt;, (\n    (myList; counter), at, currentItem\n    /// Process currentItem here\n)\n</code></pre> <p>This example shows how iteration can be implemented to access each item in <code>myList</code> using a counter.</p>"},{"location":"advanced-topics/unsort/#recursion","title":"Recursion","text":"<p>Recursion in mDm is handled by allowing functions (dSeq (direct sequence)s) to call themselves within their processing phase. The structured nature of mDm requires that recursive calls be clearly defined within the IPO model, ensuring that each recursive step is treated as a discrete dSeq (direct sequence).</p> <pre><code>/// Recursive Function Definition\n(n), factorial, result\n(n; 1), if &lt;=, (1, return, result)\n(n; (n;1), factorial, _), mul, result\n</code></pre> <p>In this recursive example, the <code>factorial</code> function calls itself with <code>n-1</code> until <code>n</code> is less than or equal to 1, demonstrating how recursion fits within the dSeq (direct sequence) paradigm.</p> <p>mDm's approach to loops, control structures, iteration, and recursion emphasizes its core philosophy of clear, structured, and modular programming. By integrating these constructs within the IPO model and dSeq (direct sequence)s framework, mDm offers a unique and powerful tool for software development, encouraging developers to think in terms of discrete processing steps and data flow.</p>"},{"location":"core-concepts/dnib/","title":"dNib","text":"<p>dNib is a conceptual tool in mDm for defining the interpretation and processing of subsequent content in memory, enhancing data management and operation precision. The Core of Memory Interpretation The primary mechanism for data interpretation in mDm is through dNibs, a term presumably derived from \"data nibble\". In typical 8-bit systems, a memory location does not inherently hold a specific data type (such as an integer, character, or address) without explicit definition. Instead, mDm uses dNibs to encode metadata about the subsequent content at a memory location, thereby directing how the content should be processed and interpreted.</p> <p>A dNib provides control over the following aspects:</p> <p>Whether the content is defined or undefined (_) If it represents the last significant bit position of a data type (.) Lock/mutex status (indicated by ~) for synchronization purposes Reserved for future use (bit 3, currently unspecified) For instance, here's how data might be represented using a dNib:</p> <p></p> <p>Memory Representation with  dNibs memoryInterpretation</p> <p>Data Types as First-Class Citizens In mDm, even fundamental data types like integers (int), floating-point numbers (float), and characters (char) are treated as constructs that must be explicitly interpreted using functions or type definitions. There is no inherent meaning to raw memory content; it gains significance only when paired with a type-defining dSeq (direct sequence) or function.</p> <p>By rejecting implicit content assumptions, mDm promotes type safety, making each operation on the data intentional and explicit. This strictness necessitates clear type definitions and operations, minimizing the risk of type errors and reducing the complexity associated with casting between types.</p> <p>Ensuring Type Safety Ensuring type safety is a cornerstone of mDm's design. Each operation that retrieves or manipulates memory content must include validation against the expected type, as encoded by the preceding dNibs. This additional layer of verification acts as a safeguard against mismatches between the intended and actual use of data.</p> <pre><code>/// Validate memory content as an integer before proceeding\n(0x01, _, memoryLocation), validateInt, safeIntOperation\n</code></pre> <p>The inclusion of dNibs in mDm establishes a methodical and secure framework for managing memory, effectively addressing one of the most prevalent sources of programmatic errors in software development. By mandating explicit definitions and operations, mDm leverages structured programming principles to enforce clarity, predictability, and reliability in code execution.</p>"},{"location":"core-concepts/dseq/","title":"dSeq","text":"<p>das IPO paradigma ist selbstkl\u00e4rend. dennoch sollten einige begrifflichkeiten erw\u00e4hnt und erkl\u00e4rt werden. Wie die: dSeq, or direct sequence, represents the structured execution flow in mDm, encompassing the IPO model's phases within a single construct.   <code>mDm   data, process, result</code></p> <p>dSeq (direct sequence)s bestehen immer(!) aus den 3 schritten:  dSeq (direct sequence) = EINGABE, VERARBEITUNG, AUSGABE trennung der schritte durch ,. die schritte werden dState genannt. dSeq (direct sequence)s sind in sich geschlossen und es wird immer von einem dState sequenziell in dieser reihenfolge zum n\u00e4chsten gesprungen. somit steht die eingabe oder parameter f\u00fcr eine operation vor der verarbeitung. das ergebnis der verarbeitung liegt instantan am ausgang an. dSeq (direct sequence)s k\u00f6nnen geklammert werden (EINGABE, VERARBEITUNG, AUSGABE) um sie verschachtelt in anderen dSeq (direct sequence)s zu verwenden. dSeq (direct sequence)s ist der einzige und fundamentale rechenschritt. in diesem sinne ist eine typendefinition, eine funktion oder ein ganzes programm eine immer eine dSeq. dSeq kann f\u00fcr deklerative zwecke benutzt werden oder auch zur implementierung. im programmier kontext unterscheiden sich die beiden: dekleration: (eingabetypen),funktionsname,(ausgabetypen) implementation: (eingangsvariabeln),(process logik), funktionsname</p> <p>verschachtelung in der form: ((dState, dState, dState), dState, dState) oder: ((dSeq, dState, dState), dSeq, dState) sind m\u00f6glich und erweitern die funktionalit\u00e4t der sprache. Der OUTPUT dState der einen dSeq kann an anderer Stelle oder in einem anderem Programmteil mit benutzt werden.</p> <p>Defining a sequence with input, process, and output.   <code>mDm   (inputData), performCalculation, outputData</code></p>"},{"location":"core-concepts/dstate/","title":"dState","text":"<p>dState refers to each phase within a dSeq, detailing the specific actions in the input, processing, or output stages.</p> <p>Specifying states within a dSeq.   <code>mDm   input, validateInput, processed   processed, computeOutput, result</code></p>"},{"location":"core-concepts/ipo-model/","title":"IPO Model","text":"<p>Alle Zuammenh\u00e4nge k\u00f6nnen durch die kleinstm\u00f6gliche Definition im Ausdruck beschrieben. Quasi Top down. At the heart of mDm lies the IPO model, which segments programs into three distinct phases: input, processing, and output. Each phase, or dState of direct sequence, adheres to a strict sequence, ensuring a linear and logical progression through the program. This model not only simplifies the design and implementation of algorithms but also aligns closely with the computational theory, enhancing the language's intuitive appeal to developers. The IPO (Input, Processing, Output) model is a fundamental principle in mDm, organizing programs/modules/types into three sequential phases: input, processing, and output. This model simplifies algorithm design and aligns with computational theory, enhancing intuitiveness for developers. Das Prinzip ist somit auch auf alle designbaren strukturen anwendbar, bis zu den gef\u00fcrchteten \"Black Boxes\" und hinein.</p>"},{"location":"practical-examples/error-handling/","title":"Error Handling in mDm","text":"<p>Error handling in mDm is managed through structured constructs, ensuring programs can gracefully manage exceptions.</p> <ul> <li>mDm Example: Handling potential errors in operations.   <code>mDm   (inputData), riskyOperation, result | errorFlag; (errorFlag), if _, (handleError, _)</code></li> </ul> <p>For each section, a corresponding Graphviz DOT diagram can be conceptualized to visually represent the described concepts, such as the flow of a dSeq with nodes for input, processing, and output phases. Due to the limitations here, I recommend using software capable of Graphviz DOT language or an online tool to create and visualize these diagrams based on the described structures.</p>"},{"location":"practical-examples/error-handling/#conclusion","title":"Conclusion","text":"<p>Throughout our session today, we delved deeply into the mDm programming language, a novel approach to structured programming that emphasizes the Input, Processing, Output (IPO) model. This exploration revealed mDm's core philosophy of making programming both intuitive and rigorous, aiming to reduce complexity and enhance clarity in software development.</p> <p>mDm introduces several innovative concepts such as dSeq (direct sequence), dState, and dNib, which collectively offer a structured methodology for defining program logic, managing data, and interpreting memory content. These constructs allow for a high degree of modularity and reusability, enabling developers to create clear, maintainable, and efficient code.</p> <p>One of the language's standout features is its insistence on explicit definitions over implicit assumptions, as encapsulated in the principle \"Implicit is wack!\" This design choice aims to eliminate the uncertainties often associated with type inference and dynamic typing, thereby reducing security vulnerabilities and making code behavior more predictable.</p> <p>The language also demonstrates a thoughtful approach to error handling, leveraging structured constructs to manage errors gracefully and ensure robust program operation even in the face of unexpected inputs or states. This is indicative of mDm's overarching goal: to provide a solid framework that supports not just the technical aspects of programming, but also the conceptual clarity needed to tackle complex software development challenges.</p> <p>Moreover, mDm's syntax and semantics encourage a paradigm shift in how we think about programming languages. By integrating the structured programming model with modern programming needs, mDm offers a pathway to a more disciplined yet flexible approach to coding. It challenges developers to think in terms of discrete processing steps and data flows, aligning closely with computational theory while also addressing practical software development needs.</p>"},{"location":"practical-examples/implementing-a-loop/","title":"Implementing a Loop","text":"<p>Loop constructs in mDm facilitate iterative operations within the IPO model.</p> <ul> <li>mDm Example: Looping through a list.   <code>mDm   (_, (index; size(myList)), while &lt;, (myList[index], processItem, _)), _</code></li> </ul>"},{"location":"practical-examples/implementing-a-loop/#looping-with-conditions","title":"Looping with conditions","text":"<p>mDm introduces a unique syntax for conditional statements and loops, maintaining its commitment to the IPO structure while accommodating control flow mechanisms essential for practical programming. These constructs allow developers to implement decision-making and iterative processes within the rigid framework of dSeq (direct sequence)s, striking a balance between structure and flexibility.</p> <p>'for'-schleifen sind nicht notwendig. mit 'while' lassen sich alle bedingungen und schleifenk\u00f6rber konstrukte abbilden.</p> <p>Loop with while</p> <p>Loops in mDm are implemented through dSeq (direct sequence)s that specify the conditions for iteration. The language uses a structured approach to define loop conditions and actions, aligning with the IPO model. For instance, a <code>while</code> loop construct might look like this:</p> <p>This example demonstrates a loop that increments <code>counter</code> until it is less than 10, showcasing how loop conditions and bodies are defined within the dSeq (direct sequence) framework. Looping is a fundamental aspect of programming, allowing for repeated execution of a block of code. This example outlines a simple loop structure in mDm.</p> <p>Here, the <code>while &lt;</code> construct illustrates how mDm implements loops, using its structured syntax to define loop conditions and actions clearly.</p>"}]}