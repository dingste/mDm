{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"abstract/","title":"Abstract","text":"<p>The mDm programming language stands as a testament to the ongoing evolution and innovation within the software development sphere, seeking to bridge the gaps identified by shortcomings in current programming paradigms and languages. Highlighting the core principles of mDm, this language aims to tackle the challenges of structured programming, modularity, and expressiveness, integrating essential feedback mechanisms and narrowing the modeling gap that lies between the problem domain and the software solution. More so, mDm allows for structuring any problem into smaller, manageable sub-problems. Conversely, partial solutions can be aggregated into a cohesive whole.</p> <p>The incorporation of feedback mechanisms and the focus on minimizing the modeling gap through expressive syntax and constructs in mDm demonstrate an acknowledgment of the need for programming languages and environments to align more closely with the conceptualization and design of systems. This vision aligns with that of Krasemann, wherein the development process is augmented by tools that offer immediate feedback, enable direct manipulation of program structures, and facilitate a seamless transition between design and implementation phases.</p> <p>By advocating a structured approach to programming through the IPO model and direct sequences (dSeq), mDm not only streamlines the software development process but also fosters clarity and predictability in program behavior. Adhering to the principles of structured programming ensures that developers can craft more maintainable, readable, and robust applications, addressing core deficiencies identified by Floyd and others concerning the necessity for a broad spectrum of paradigms supported by programming languages.</p> <p>Furthermore, the utilization of macros, groupings, and the scope operator ::: in mDm promotes a degree of modularity and reusability crucial for contemporary software development practices. This methodology is in line with the vision of establishing a comprehensive language workbench in which domain-specific languages (DSLs) and meta-programming are pivotal in customizing the programming environment to meet the specific requirements of the problem domain.</p> <p>In conclusion, mDm embodies a progressive stance on programming language design, aiming to encapsulate the principles and vision for future programming paradigms and environments. By addressing the limitations of existing languages, offering mechanisms for modularity and expressiveness, and underscoring the significance of feedback and reduced modeling gaps, mDm provides a preview into the prospective future of software development. As we persist in our exploration and innovation within the programming language realm, mDm represents a significant stride towards achieving a more expressive and efficient programming environment. ([source] May 7, 2006, Requirements for a Programming Language, H. Krasemann)</p>"},{"location":"introduction/","title":"Introduction","text":"<p>Programming languages are foundational to software development, translating human logic into commands that machines can execute. mDm is introduced as a language based on the structured paradigm of input, processing, and output (IPO) modules, similar to the computation by classic von Neumann architecture. This three-part structure is termed dSeq (direct sequence). The architecture promotes a clear separation of concerns, modular design, and improved readability, thereby setting the stage for efficient and error-reduced coding practices. While no existing programming language perfectly aligns with the unique combination of features and paradigms mDm proposes, many languages do include elements that align with its fundamental principles. The design of mDm represents a synthesis of structured programming, type safety, modularity, and a distinct IPO model, drawing inspiration from both functional and system programming languages to meet contemporary software development challenges. Specifically, its modularity allows for a more explicit approach to addressing every problem expressed.</p> <p>Document under:                                  Apache License                            Version 2.0, January 2004                         http://www.apache.org/licenses/</p>"},{"location":"advanced-topics/dynamic-memory-management/","title":"Dynamic Memory Management","text":"<p>By allowing data to be stored either directly or through address references (indirectly), the system can dynamically decide how and where to allocate memory. For small data values that fit directly next to the dNib, memory space can be conserved since no additional references are required. Larger data structures or those that can grow dynamically, such as lists or strings, utilize indirect referencing, allowing memory allocation to be tailored to needs and in variable sizes.</p> <p>In einem adaptiven Runtime-System, das auf der rekursiven Natur von dSeqs und den pr\u00e4zise definierten Typen aus <code>type6.mdmD</code> basiert, ergibt sich die Speicherverwaltung organisch aus der Struktur der Programme selbst. Jeder Typ und jede dSeq bringt seine eigene Spezifikation bez\u00fcglich des ben\u00f6tigten Speicherplatzes mit, was es der Runtime erm\u00f6glicht, den Speicher dynamisch anzupassen, je nachdem, welche Typen und dSeqs zur Laufzeit verwendet werden.</p>"},{"location":"advanced-topics/dynamic-memory-management/#adaptives-speichermanagement","title":"Adaptives Speichermanagement","text":"<p>Die Runtime-Umgebung nutzt die Information \u00fcber die Bitgr\u00f6\u00dfe jedes Typs, um den notwendigen Speicher f\u00fcr Variablen, Zwischenergebnisse und andere Datenstrukturen zuzuweisen und freizugeben. Die Speicherverwaltung erfolgt dabei dynamisch und effizient:</p> <ol> <li> <p>Speicherzuweisung bei der Initialisierung: Beim Start eines dSeq oder der Erstellung einer Variable berechnet die Runtime den erforderlichen Speicherplatz basierend auf den definierten Typen und weist diesen zu.</p> </li> <li> <p>Dynamische Speicheranpassung: Wenn ein dSeq weitere dSeqs rekursiv aufruft oder komplexe Datenstrukturen manipuliert, passt die Runtime den Speicherbedarf entsprechend an. Dies umfasst sowohl die Erweiterung des Speichers f\u00fcr neue Daten als auch die Freigabe von Speicher, der nicht mehr ben\u00f6tigt wird.</p> </li> <li> <p>Effiziente Speichernutzung: Die genaue Definition von Datentypen und deren Gr\u00f6\u00dfe erm\u00f6glicht eine optimierte Speichernutzung, indem genau der Speicher reserviert wird, der ben\u00f6tigt wird, ohne \u00dcberbelegung.</p> </li> </ol>"},{"location":"advanced-topics/dynamic-memory-management/#implementierungshinweise","title":"Implementierungshinweise","text":"<ul> <li>Typbasierte Speicherallokation: Die Runtime muss in der Lage sein, die Speichergr\u00f6\u00dfe f\u00fcr jeden Typ und jede Datenstruktur, die in <code>type6.mdmD</code> definiert ist, genau zu berechnen und entsprechend Speicher zuzuweisen.</li> <li>Garbage Collection: Um effizient mit dem Speicher umzugehen, k\u00f6nnte die Runtime eine Form der Garbage Collection oder Speicherbereinigung implementieren, die nicht mehr ben\u00f6tigte Daten automatisch freigibt, insbesondere bei rekursiven dSeq-Aufrufen.</li> <li>Debugging und Speicher\u00fcberwachung: Tools und Mechanismen f\u00fcr das Debugging und die \u00dcberwachung der Speichernutzung sind wichtig, um Speicherlecks zu vermeiden und die Performance von mDm-Programmen zu optimieren.</li> </ul>"},{"location":"advanced-topics/dynamic-memory-management/#vorteile-dieses-ansatzes","title":"Vorteile dieses Ansatzes","text":"<ul> <li>Skalierbarkeit: Die Speicherverwaltung skaliert dynamisch mit den Anforderungen des Programms, ohne dass manuelle Speicherallokation oder -freigabe erforderlich ist.</li> <li>Performance: Durch die pr\u00e4zise Allokation nur des ben\u00f6tigten Speichers und die effiziente Wiederverwendung kann die Runtime optimale Performance gew\u00e4hrleisten.</li> <li>Sicherheit und Stabilit\u00e4t: Ein gut gestaltetes Speichermanagementsystem reduziert die Wahrscheinlichkeit von Speicher\u00fcberl\u00e4ufen und anderen speicherbezogenen Fehlern.</li> </ul> <p>Diese \u00dcberlegungen zur Speicherverwaltung in einer mDm-Runtime reflektieren die einzigartige Kombination aus Flexibilit\u00e4t und Effizienz, die durch die rekursive Struktur von dSeqs und die pr\u00e4zise Definition von Datentypen erm\u00f6glicht wird. Durch die enge Integration von Typsystem, Speichermanagement und Programmausf\u00fchrung kann die Runtime eine robuste Plattform f\u00fcr die Entwicklung und Ausf\u00fchrung von mDm-Programmen bieten.</p>"},{"location":"advanced-topics/efficient-memory-usage/","title":"Efficient Memory Usage","text":"<p>Separating metadata (dNib) from data enables more efficient use of memory. Since the dNib carries information about the data type and structure, memory can be precisely allocated according to the requirements of data allocation, leading to minimized waste of memory space. For example, empty or undefined areas can be easily identified and reused or overwritten without the need for extensive garbage collection processes.</p>"},{"location":"advanced-topics/explicitly-defining-a-variable-type/","title":"Explicitly Defining a Variable Type","text":"<p>This adaptation emphasizes mDm's innovative features and principles, such as dynamic memory management, the importance of explicit over implicit in programming, and the structuring of complex data types, fostering a clear, modular, and expressive programming environment.</p>"},{"location":"advanced-topics/implicit-is-wack/","title":"Implicit is Wack!","text":"<p>Emphasizing explicit definitions over implicit assumptions, this principle in mDm aims to eliminate uncertainties in data type interpretation and usage. mDm's approach to programming language design is ambitious and innovative, incorporating structured programming principles with modern features like macros, groupings, and advanced data handling. Let's explore the detailed syntax description and how type declarations for common data types are structured in mDm, highlighting its unique paradigm focused on input, processing, and output (dSeqs).</p> <pre><code>Type Annotations in dSeqs: When defining dSeqs, type annotations can explicitly declare the types of inputs, processing steps, and outputs. This clarity supports mDm's objective of making each dSeq self-contained and understandable.\nType Safety in Modular Design: mDm's modular design, emphasizing modules, packages, and namespaces, leverages type safety to ensure correct usage of interfaces between different parts of the program and appropriate sharing or isolation of data.\nType Inference for Ease of Use: Type inference in mDm could be particularly beneficial for writing concise and expressive code, especially when complex operations or algorithms allow for clear type inference from the context.\n</code></pre>"},{"location":"advanced-topics/improvement-of-memory-access-times/","title":"Improvement of Memory Access Times","text":"<p>By efficiently distributing data according to their use and size in memory, memory access times can be optimized. Directly referenced data offer fast access for small amounts of data, while indirectly referenced structures provide the flexibility to efficiently manage large and complex data.</p> <pre><code>(address, dNib::Type, content), defineData, usage\n</code></pre>"},{"location":"advanced-topics/optimization-for-specific-use-cases/","title":"Optimization for Specific Use Cases","text":"<p>Through flexible handling of memory allocation, applications can make specific optimizations, such as by pre-allocating and reusing frequently used data structures. This reduces the need for constant allocations and releases of memory, improving the overall performance of the application.</p>"},{"location":"advanced-topics/simplification-of-memory-release/","title":"Simplification of Memory Release","text":"<p>The clear marking of data end and type by the dNib facilitates the release of memory. When a data block is no longer needed, the system can examine the dNib to determine how and where the data are stored (directly or indirectly) and release the corresponding memory. This is particularly useful in environments with manual memory management but can also support automated garbage collection methods.</p>"},{"location":"advanced-topics/support-for-complex-data-structures/","title":"Support for Complex Data Structures","text":"<p>The use of address references enables the creation of complex, linked data structures, such as linked lists, trees, and graphs, without the need to hold the entire structure in a continuous memory block. This makes it easier to allocate memory for new elements since only the memory for the element itself and not for the entire structure needs to be allocated. Additionally, structure elements can be distributed in memory, optimizing memory usage.</p>"},{"location":"advanced-topics/type-system/","title":"Type System","text":"<p>Verwendung der importierten Typdefinitionen aus types6.mdmD k\u00f6nnen wir spezifische Funktionen f\u00fcr Typ\u00fcberpr\u00fcfungen und -konversionen definieren. Typsystem und Typ\u00fcberpr\u00fcfung</p> <p>Zun\u00e4chst importieren wir die Typdefinitionen:</p> <p>mDm</p> <p>import types6.mdmD</p> <p>Dann definieren wir die Funktionen f\u00fcr Typ\u00fcberpr\u00fcfungen und -konversionen entsprechend deinen Anpassungen: Typ\u00fcberpr\u00fcfung</p> <p>Die Typ\u00fcberpr\u00fcfungsfunktion nimmt zwei Typen entgegen und gibt einen booleschen Wert zur\u00fcck, der angibt, ob die Typen \u00fcbereinstimmen. Diese Funktion ist essentiell f\u00fcr die Sicherstellung der Typsicherheit bei der Verarbeitung von Daten.</p> <p>mDm</p> <p>(type; type), checkType, (bool)</p> <p>Diese Funktion k\u00f6nnte intern pr\u00fcfen, ob die beiden Typen kompatibel sind. Das Ergebnis true signalisiert Kompatibilit\u00e4t, w\u00e4hrend false einen Typkonflikt anzeigt. Typkonversion</p> <p>Die Typkonversionsfunktion nimmt einen Wert und einen Zieltyp entgegen und versucht, den Wert in den Zieltyp zu konvertieren. Die Konversion kann je nach den beteiligten Typen bestimmte Regeln befolgen und k\u00f6nnte in einigen F\u00e4llen nicht zul\u00e4ssig sein, was durch die R\u00fcckgabe eines speziellen Werts oder eines Fehlers signalisiert wird.</p> <p>mDm</p> <p>(, type), convertType, ()</p> <p>Diese Funktion w\u00fcrde versuchen, den gegebenen Wert in den spezifizierten Zieltyp zu konvertieren. Die Details der Implementierung w\u00fcrden davon abh\u00e4ngen, wie Typkonversionen in mDm behandelt werden, einschlie\u00dflich der Behandlung von Fehlern oder unzul\u00e4ssigen Konversionen.</p>"},{"location":"advanced-topics/unsort/","title":"Unsort","text":""},{"location":"advanced-topics/unsort/#dynamische-speicherverwaltung","title":"Dynamische Speicherverwaltung","text":"<p>Durch die M\u00f6glichkeit, Daten entweder direkt oder \u00fcber Adressverweise (indirekt) zu speichern, kann das System dynamisch entscheiden, wie und wo Speicher alloziert wird. F\u00fcr kleine Datenwerte, die direkt neben dem dNib passen, kann Speicherplatz eingespart werden, da keine zus\u00e4tzlichen Verweise n\u00f6tig sind. Gr\u00f6\u00dfere Datenstrukturen oder solche, die dynamisch wachsen k\u00f6nnen, wie Listen oder Strings, nutzen indirekte Referenzierung, wodurch die Allokation von Speicher nach Bedarf und in variablen Gr\u00f6\u00dfen m\u00f6glich wird.</p>"},{"location":"advanced-topics/unsort/#effiziente-nutzung-des-speichers","title":"Effiziente Nutzung des Speichers","text":"<p>Die Trennung von Metadaten (dNib) und Daten erm\u00f6glicht eine effizientere Nutzung des Speichers. Da das dNib Informationen \u00fcber den Datentyp und die Struktur tr\u00e4gt, kann der Speicher genau nach den Erfordernissen der Datenallokation angepasst werden, was zu einer Minimierung von verschwendetem Speicherplatz f\u00fchrt. Beispielsweise k\u00f6nnen leere oder undefinierte Bereiche leicht identifiziert und wiederverwendet oder \u00fcberschrieben werden, ohne umfangreiche Garbage Collection durchf\u00fchren zu m\u00fcssen.</p>"},{"location":"advanced-topics/unsort/#vereinfachung-der-speicherfreigabe","title":"Vereinfachung der Speicherfreigabe","text":"<p>Die klare Kennzeichnung von Datenende und Typ durch das dNib erleichtert die Freigabe von Speicher. Wenn ein Datenblock nicht mehr ben\u00f6tigt wird, kann das System das dNib untersuchen, um zu bestimmen, wie und wo die Daten gespeichert sind (direkt oder indirekt), und den entsprechenden Speicher freigeben. Dies ist besonders n\u00fctzlich in Umgebungen mit manueller Speicherverwaltung, kann aber auch automatisierte Garbage Collection-Verfahren unterst\u00fctzen.</p>"},{"location":"advanced-topics/unsort/#unterstutzung-fur-komplexe-datenstrukturen","title":"Unterst\u00fctzung f\u00fcr komplexe Datenstrukturen","text":"<p>Die Verwendung von Adressverweisen erm\u00f6glicht die Erstellung komplexer, verkn\u00fcpfter Datenstrukturen, wie verkettete Listen, B\u00e4ume und Graphen, ohne die Notwendigkeit, die gesamte Struktur in einem kontinuierlichen Speicherblock zu halten. Dies erleichtert die Allokation von Speicher f\u00fcr neue Elemente, da nur der Speicher f\u00fcr das Element selbst und nicht f\u00fcr die gesamte Struktur allokiert werden muss. Zudem k\u00f6nnen Strukturelemente im Speicher verteilt werden, was die Speichernutzung optimiert.</p>"},{"location":"advanced-topics/unsort/#optimierung-fur-spezifische-anwendungsfalle","title":"Optimierung f\u00fcr spezifische Anwendungsf\u00e4lle","text":"<p>Durch die flexible Handhabung der Speicherallokation k\u00f6nnen Anwendungen spezifische Optimierungen vornehmen, beispielsweise indem h\u00e4ufig genutzte Datenstrukturen im Voraus alloziert und wiederverwendet werden. Dies reduziert die Notwendigkeit f\u00fcr st\u00e4ndige Allokationen und Freigaben von Speicher und verbessert die Gesamtleistung der Anwendung.</p>"},{"location":"advanced-topics/unsort/#verbesserung-der-speicherzugriffszeiten","title":"Verbesserung der Speicherzugriffszeiten","text":"<p>Indem Daten entsprechend ihrer Nutzung und Gr\u00f6\u00dfe effizient im Speicher verteilt werden, k\u00f6nnen Speicherzugriffszeiten optimiert werden. Direkt referenzierte Daten bieten schnellen Zugriff f\u00fcr kleine Datenmengen, w\u00e4hrend indirekt referenzierte Strukturen die Flexibilit\u00e4t bieten, gro\u00dfe und komplexe Daten effizient zu verwalten.</p> <ul> <li>mDm Example: Using dNib for data interpretation.   <code>mDm   (address, dNib::Type, content), defineData, usage</code></li> </ul>"},{"location":"advanced-topics/unsort/#implicit-is-wack","title":"Implicit is Wack!","text":"<p>Promoting explicit definitions over implicit assumptions, this principle in mDm aims to eliminate uncertainties in data type interpretation and usage. Eine detaillierte Erl\u00e4uterung des Typsystems von mDm, einschlie\u00dflich der unterst\u00fctzten Datentypen (wie Integer, Float, String, Listen, usw.), sowie Regeln f\u00fcr Typkonversion und Typinferenz. mDm's approach to programming language design is ambitious and innovative, drawing inspiration from structured programming principles and incorporating modern features like macros, groupings, and advanced data handling. Let's dive into the detailed syntax description and how type declarations for common data types are structured in mDm, reflecting on its distinctive paradigm that focuses on input, processing, and output (dSeq (direct sequence)s).</p> <ul> <li>Type Annotations in dSeq (direct sequence)s: In defining dSeq (direct sequence)s, type annotations can be used to explicitly declare the types of inputs, processing steps, and outputs. This clarity supports mDm's goal of making each dSeq (direct sequence) self-contained and understandable.</li> <li>Type Safety in Modular Design: The modular design of mDm, with its emphasis on modules, packages, and namespaces, would leverage type safety to ensure that interfaces between different parts of the program are correctly used and that data is appropriately shared or isolated.</li> <li>Type Inference for Ease of Use: Type inference would be particularly useful in making mDm code concise and expressive, especially when writing complex operations or algorithms where the types can be clearly inferred from the context.</li> <li></li> <li>mDm Example: Explicitly defining a variable type.   <code>mDm   (42, int, myVariable)</code></li> </ul>"},{"location":"advanced-topics/unsort/#legacy-compare","title":"Legacy Compare","text":""},{"location":"advanced-topics/unsort/#function-body","title":"Function body","text":"<p>Das Kapitel \u00fcber Funktionsk\u00f6rper in der mDm Programmiersprache illustriert die Art und Weise, wie Funktionen definiert und verwendet werden. In mDm wird jede Funktion oder dState (direkte Sequenz) als eine Struktur mit drei Hauptteilen betrachtet: Eingabe, Verarbeitung und Ausgabe. Dies folgt dem grundlegenden Prinzip von mDm, das Programmieren durch klare und strukturierte Abl\u00e4ufe zu vereinfachen.</p> <p>Die Definition einer Funktion in mDm folgt dem Schema:</p> <pre><code>FUNKTIONSPARAMETER,(\n    FUNKTIONSK\u00d6RPER\n),FUNKTIONSNAME\n</code></pre> <p>Dies entspricht dem Modell: Eingabe, Verarbeitung, Ausgabe. An der Speicherstelle <code>FUNKTIONSNAME</code> liegt das Ergebnis, also der Returnwert der Funktion, als letzter Verarbeitungsschritt an.  Ein einfaches Beispiel k\u00f6nnte eine Funktion sein, die zwei Zahlen addiert, gleich einer Dekleration:</p> <p>math</p> <p>In diesem Beispiel sind <code>a</code> und <code>b</code> die Eingabeparameter f\u00fcr die Funktion. Der Funktionsk\u00f6rper f\u00fchrt die Addition durch (<code>a + b</code>), und das Ergebnis dieser Verarbeitung wird unter dem Funktionsnamen <code>addiere</code> abgelegt. Um eine solche Funktion aufzurufen und das Ergebnis zu nutzen, k\u00f6nnte der Code wie folgt aussehen, gleich einer implementierung: Hier werden <code>5</code> und <code>3</code> als Eingabeparameter an die Funktion <code>addiere</code> \u00fcbergeben. Das Ergebnis der Addition wird in der Variablen <code>ergebnis</code> gespeichert.</p>"},{"location":"advanced-topics/unsort/#importing","title":"Importing","text":"<p>mDm streamlines external dependencies and modular programming with straightforward import syntax. The language simplifies external dependencies and modular programming through its import constructs, allowing for the inclusion of libraries and modules with a straightforward syntax. This approach to dependency management streamlines code organization and reuse.</p> <p>mDm defines clear rules for importing and exporting code elements to manage dependencies and ensure that only the necessary parts of a module or package are exposed to the rest of the program.</p> <ul> <li> <p>Importing: When a module or package needs to use functions, classes, or other elements defined elsewhere, it can import them using mDm's import statement. The import mechanism specifies how and which components of a module or package can be accessed by others, promoting loose coupling and high cohesion within and across modules.</p> </li> <li> <p>To import a module or specific functionalities from a module, mDm uses syntax that might look similar to <code>(iostream; string), import, IO</code>, where <code>iostream</code> and <code>string</code> are the modules or functionalities being imported, and <code>IO</code> is an optional alias to refer to the imported entities.</p> </li> <li> <p>Exporting: Modules and packages in mDm specify what functionalities they make available to other parts of the program or to other programs. Exporting is controlled through specific statements that declare which dSeq (direct sequence)s, functions, or classes can be used externally. This ensures that internal details of a module or package can remain hidden, exposing only a defined interface to the outside world.</p> </li> <li> <p>An export statement in mDm clearly marks which components are intended for external use, potentially using syntax. existing of dSeq (direct sequence)s in same memory region, they are inherent exported, cause of all dSeq (direct sequence)s are public in that memory. outside of own memory region, the dSeq (direct sequence)s arn't resolved.</p> </li> <li> <p>mDm Example: Importing a module.</p> </li> </ul>"},{"location":"advanced-topics/unsort/#declaring-variables-types","title":"Declaring (Variables / Types)","text":"<p>Variable and type declarations in mDm follow a structured syntax, enhancing clarity and modularity. Eine detaillierte Erl\u00e4uterung des Typsystems von mDm, einschlie\u00dflich der unterst\u00fctzten Datentypen (wie Integer, Float, String, Listen, usw.), sowie Regeln f\u00fcr Typkonversion und Typinferenz. mDm's approach to programming language design is ambitious and innovative, drawing inspiration from structured programming principles and incorporating modern features like macros, groupings, and advanced data handling. Let's dive into the detailed syntax description and how type declarations for common data types are structured in mDm, reflecting on its distinctive paradigm that focuses on input, processing, and output (dSeq (direct sequence)s).</p> <ul> <li>Type Annotations in dSeq (direct sequence)s: In defining dSeq (direct sequence)s, type annotations can be used to explicitly declare the types of inputs, processing steps, and outputs. This clarity supports mDm's goal of making each dSeq (direct sequence) self-contained and understandable.</li> <li>Type Safety in Modular Design: The modular design of mDm, with its emphasis on modules, packages, and namespaces, would leverage type safety to ensure that interfaces between different parts of the program are correctly used and that data is appropriately shared or isolated.</li> <li>Type Inference for Ease of Use: Type inference would be particularly useful in making mDm code concise and expressive, especially when writing complex operations or algorithms where the types can be clearly inferred from the context.</li> </ul> <p>The declaration of common data types in mDm emphasizes the language's structured and modular design. Here are examples of how various data types can be declared:</p> <p>Type example</p> <p>Um auf Basis des dNib-Konzepts in mDm weitere Datentypen wie char, string, numerical, fraction, und list zu deklarieren, wobei jedem Wert ein dNib vorangestellt ist, kann man die Speicherstruktur und -interpretation entsprechend planen. Angesichts einer 32-Bit-Architektur, bei der nach Abzug des dNib 28 Bit f\u00fcr den eigentlichen Wert verbleiben, ergeben sich interessante M\u00f6glichkeiten f\u00fcr die Darstellung und Verwaltung dieser Typen. Hier ein \u00dcberblick \u00fcber eine m\u00f6gliche Implementierung dieser Datentypen unter Ber\u00fccksichtigung des dNib: Char</p> <pre><code>Ein char k\u00f6nnte direkt in den verbleibenden 28 Bit gespeichert werden, wobei das dNib Informationen \u00fcber den Typ (z.B. dass es sich um ein Zeichen handelt) und m\u00f6glicherweise \u00fcber die Codierung enth\u00e4lt. Bei Bedarf k\u00f6nnten Zeichen, die mehr als 28 Bit erfordern, \u00fcber mehrere Speicherstellen verteilt werden, mit einem fortlaufenden dNib, das anzeigt, dass das Zeichen \u00fcber die erste Speicherstelle hinausgeht.\n</code></pre>"},{"location":"advanced-topics/unsort/#string","title":"String","text":"<pre><code>Ein string w\u00fcrde aus einer Sequenz von char bestehen, wobei jedes Zeichen sein eigenes dNib besitzt. Das EndOfTyp-dNib am Ende des Strings signalisiert das Ende der Zeichenkette. F\u00fcr l\u00e4ngere Texte, die mehrere Speicherstellen ben\u00f6tigen, w\u00fcrden fortlaufende dNibs die Zugeh\u00f6rigkeit zum gleichen String anzeigen, bis ein dNib mit der Markierung EndOfType das Ende kennzeichnet.\n</code></pre>"},{"location":"advanced-topics/unsort/#numerical","title":"Numerical","text":"<pre><code>Numerische Typen (int, float etc.) w\u00fcrden \u00e4hnlich behandelt. Ein numerical k\u00f6nnte in 28 Bit oder \u00fcber mehrere Speicherstellen f\u00fcr gr\u00f6\u00dfere Genauigkeit oder Wertebereiche verteilt werden. Das dNib w\u00fcrde hierbei den Typ (z.B. Ganzzahl oder Flie\u00dfkommazahl) und das Ende der Zahl (EndOfType) markieren.\n</code></pre>"},{"location":"advanced-topics/unsort/#fraction","title":"Fraction","text":"<pre><code>Eine fraction (Bruch) k\u00f6nnte als zwei numerical Werte dargestellt werden, einer f\u00fcr den Z\u00e4hler und einer f\u00fcr den Nenner, jeweils mit eigenen dNibs. Ein drittes dNib k\u00f6nnte das Ende der fraction markieren und somit die beiden Teile als zusammengeh\u00f6rig definieren.\n</code></pre>"},{"location":"advanced-topics/unsort/#list","title":"List","text":"<pre><code>Eine list w\u00e4re eine Sequenz von Werten (z.B. char, numerical, andere lists), wobei jedes Element durch ein dNib gekennzeichnet ist. Das Ende einer Liste w\u00fcrde durch ein EndOfType-dNib gekennzeichnet. F\u00fcr verschachtelte Listen w\u00fcrde jedes Listenelement sein eigenes dNib haben, das den Beginn einer neuen Liste markiert, gefolgt von den Elementen dieser Unternliste, bis ein EndOfType-dNib das Ende anzeigt.\n</code></pre>"},{"location":"advanced-topics/unsort/#complex-types-struct-like","title":"Complex Types (Struct-like)","text":"<p>mDm allows for the definition of complex data types, akin to structs in C or objects in other object-oriented languages. This can be done by defining a sequence of elements, each with its own type and identifier, grouped together:</p> <p>This syntax showcases mDm's unique approach to programming language design, focusing on clarity, modularity, and the seamless integration of structured programming principles. It's designed to encourage developers to think about the flow of data through their programs, making the development process more intuitive and aligned with computational theory.</p>"},{"location":"advanced-topics/unsort/#defining-complex-data-types","title":"Defining Complex Data Types","text":"<p>mDm supports the definition of complex data types through a sequence of elements, each characterized by its own IPO schema. This feature exemplifies the language's strong typing and modular design principles, enabling precise and clear data modeling. zusammen gesetzte datentypen, d.h. sie werden in mDm durch () gebildet, siehe Complex Types:</p> <pre><code>((1,int,zaehler);(2,int, nenner)), fracture, afracture\n</code></pre> <pre><code>((_,char,_);(2,int, length)), string, astring\n</code></pre> <p>gleiches gilt f\u00fcr: dSeq (direct sequence)s, list, ...</p> <p>In the conceptual framework of mDm, type safety and type inference are critical features designed to enhance the language's reliability, readability, and ease of use. These features align with mDm's overarching goals of structured programming, modularity, and clarity.</p>"},{"location":"advanced-topics/unsort/#counting","title":"Counting","text":"<p>Demonstrates handling numeric operations and counters in mDm.</p> <ul> <li>mDm Example: Incrementing a counter.   <code>mDm   (counter; 1), add, counter</code></li> </ul>"},{"location":"advanced-topics/unsort/#operating","title":"Operating","text":"<p>Showcases basic arithmetic and logical operations within the structured syntax of mDm. mDm's capability to perform arithmetic operations is shown in this straightforward example, demonstrating the language's approach to basic mathematical tasks.</p> <p>By specifying the inputs, operation, and output, mDm maintains clarity and precision in expressing arithmetic, adhering to its structured programming model.</p>"},{"location":"advanced-topics/unsort/#conditions","title":"Conditions","text":"<p>Conditional statements in mDm allow for decision-making based on dynamic data. zur weiteren verarbeitung m\u00fcssen bedingungen erf\u00fcllt sein. sind sie nicht erf\u00fcllt, sind sie f\u00fcr dSeq (direct sequence)s nicht wahr. mit dem '' undefined macro k\u00f6nnen sie weiter verarbeitet werden, mit undefinierten verhalten. weitere verarbeitungsschritte sind notwendig, um '' auf wahren inhalt zu pr\u00fcfen und f\u00fcr die weitere verarbeitung entscheidbar zu machen. Implementing conditional logic in mDm, this example handles decision-making based on user input, showcasing the language's support for dynamic and conditional operations.</p> <p>Control structures, including conditional statements, are represented in mDm using a similar dSeq (direct sequence) syntax, which integrates seamlessly with the language's structured programming approach. Conditionals are defined by specifying the condition as part of the input, the evaluation as the process, and the consequent action as the output.</p> <p>This snippet illustrates a conditional check on <code>userInput</code> to determine if it is greater than or equal to 18, and prints \"Adult\" if the condition is true.</p> <p>The conditional operation <code>if &gt;=</code> demonstrates mDm's ability to execute different paths based on runtime conditions, a crucial feature for responsive programs. mDm handles loops, control structures, iteration, and recursion within its unique framework of dSeq (direct sequence)s and the IPO (Input, Processing, Output) model, adhering to its structured approach to programming. The language's design principles facilitate clear and concise representation of these constructs, emphasizing modularity and predictability. </p> <p>Condition examples</p>"},{"location":"advanced-topics/unsort/#iteration","title":"Iteration","text":"<p>Iteration over collections like lists or arrays is handled through dSeq (direct sequence) constructs that allow for accessing and manipulating elements in a sequence. mDm's syntax for iteration is designed to work with its structured approach, enabling developers to specify the operation to be performed on each element of the collection.</p> <pre><code>/// Variable\n0, int, counter\n(1;2;3;4;5), list, myList\n\n/// Iteration Construct\n(counter; size(myList)), while &lt;, (\n    (myList; counter), at, currentItem\n    /// Process currentItem here\n)\n</code></pre> <p>This example shows how iteration can be implemented to access each item in <code>myList</code> using a counter.</p>"},{"location":"advanced-topics/unsort/#recursion","title":"Recursion","text":"<p>Recursion in mDm is handled by allowing functions (dSeq (direct sequence)s) to call themselves within their processing phase. The structured nature of mDm requires that recursive calls be clearly defined within the IPO model, ensuring that each recursive step is treated as a discrete dSeq (direct sequence).</p> <pre><code>/// Recursive Function Definition\n(n), factorial, result\n(n; 1), if &lt;=, (1, return, result)\n(n; (n;1), factorial, _), mul, result\n</code></pre> <p>In this recursive example, the <code>factorial</code> function calls itself with <code>n-1</code> until <code>n</code> is less than or equal to 1, demonstrating how recursion fits within the dSeq (direct sequence) paradigm.</p> <p>mDm's approach to loops, control structures, iteration, and recursion emphasizes its core philosophy of clear, structured, and modular programming. By integrating these constructs within the IPO model and dSeq (direct sequence)s framework, mDm offers a unique and powerful tool for software development, encouraging developers to think in terms of discrete processing steps and data flow.</p>"},{"location":"core-concepts/dnib/","title":"dNib","text":"<p>dNib is a conceptual tool in mDm for defining the interpretation and processing of subsequent content in memory, enhancing data management and operation precision. The Core of Memory Interpretation The primary mechanism for data interpretation in mDm is through dNibs, a term presumably derived from \"data nibble\". In typical 8-bit systems, a memory location does not inherently hold a specific data type (such as an integer, character, or address) without explicit definition. Instead, mDm uses dNibs to encode metadata about the subsequent content at a memory location, thereby directing how the content should be processed and interpreted.</p> <p>A dNib provides control over the following aspects:</p> <p>Whether the content is defined or undefined (_) If it represents the last significant bit position of a data type (.) Lock/mutex status (indicated by ~) for synchronization purposes Reserved for future use (bit 3, currently unspecified) For instance, here's how data might be represented using a dNib:</p> <p></p> <p>Memory Representation with  dNibs memoryInterpretation</p> <p>Data Types as First-Class Citizens In mDm, even fundamental data types like integers (int), floating-point numbers (float), and characters (char) are treated as constructs that must be explicitly interpreted using functions or type definitions. There is no inherent meaning to raw memory content; it gains significance only when paired with a type-defining dSeq (direct sequence) or function.</p> <p>By rejecting implicit content assumptions, mDm promotes type safety, making each operation on the data intentional and explicit. This strictness necessitates clear type definitions and operations, minimizing the risk of type errors and reducing the complexity associated with casting between types.</p> <p>Ensuring Type Safety Ensuring type safety is a cornerstone of mDm's design. Each operation that retrieves or manipulates memory content must include validation against the expected type, as encoded by the preceding dNibs. This additional layer of verification acts as a safeguard against mismatches between the intended and actual use of data.</p> <p>The inclusion of dNibs in mDm establishes a methodical and secure framework for managing memory, effectively addressing one of the most prevalent sources of programmatic errors in software development. By mandating explicit definitions and operations, mDm leverages structured programming principles to enforce clarity, predictability, and reliability in code execution.</p> <p>Speicher</p> <p>|-------------------| | Byte 0 (Nibble 0) | |-------------------| | Byte 1 (Nibble 1) | |-------------------| | ...               | |-------------------| | Byte n-1 (Nibble 2n-2) | |-------------------| | Byte n (Nibble 2n-1) | |-------------------|</p> <p>Legende:</p> <ul> <li>Speicher: Der Speicherbereich, in dem Daten gespeichert werden.</li> <li>Byte: Eine Einheit von 8 Bits.</li> <li>Nibble: Eine Einheit von 4 Bits.</li> <li>dNib: Eine spezielle Struktur, bei der ein Byte in zwei Nibbles mit jeweils 4 Bits unterteilt wird.</li> </ul> <p>Speicherorganisation:</p> <ul> <li>Daten werden in Bytes gespeichert.</li> <li>Jedes Byte besteht aus zwei Nibbles.</li> <li>Die Nibbles werden in der Reihenfolge 0, 1, 2, ... n-1, 2n-2, 2n-1 gespeichert.</li> </ul> <p>Beispiel:</p> <ul> <li>Angenommen, wir haben den Wert 0xABCDEF in einem Byte gespeichert.</li> <li>Die Nibble-Darstellung w\u00e4re 0xA, 0xB, 0xC, 0xD, 0xE, 0xF.</li> <li>Nibble 0 (0xA) und Nibble 3 (0xE) bilden das erste Byte.</li> <li>Nibble 1 (0xB) und Nibble 4 (0xF) bilden das zweite Byte.</li> <li>Nibble 2 (0xC) und Nibble 5 (0xD) bilden das dritte Byte.</li> </ul> <p>Vorteile der dNib-Struktur:</p> <ul> <li>Geringerer Speicherbedarf im Vergleich zu 8-Bit-Bytes.</li> <li>Effizientere Nutzung des Speichers, insbesondere bei kleinen Datenmengen.</li> </ul> <p>Einschr\u00e4nkungen:</p> <ul> <li>Die dNib-Struktur ist m\u00f6glicherweise nicht f\u00fcr alle Plattformen und Implementierungen von mDm verf\u00fcgbar.</li> <li>Die genaue Speicherorganisation kann je nach Plattform und Implementierung variieren.</li> </ul> <p>Zusammenfassend l\u00e4sst sich sagen, dass die dNib-Struktur eine einzigartige Speicherorganisation in mDm ist, die Vorteile in Bezug auf den Speicherbedarf bietet, aber auch einige Herausforderungen mit sich bringt.</p> <p>Bei einer 8-Bit Architekturbreite und unter Verwendung von 2 Bits (als dNibs bezeichnet) f\u00fcr spezielle Zwecke, bleibt folgende Aufteilung:</p> <pre><code>Bit 0 bestimmt, ob es sich um eine Adresse (0) oder um ein Datum (1) handelt.\nBit 1 markiert das Ende einer Adresse oder eines Datums (1 signalisiert das Ende).\n</code></pre> <p>In einem einzelnen 8-Bit Byte, nach Abzug der 2 dNibs, verbleiben 6 Bits f\u00fcr die eigentliche Information (Adresse oder Datum).</p> <p>Wenn man jedoch zwei solcher Bytes kombiniert und jeweils 2 dNibs f\u00fcr die Markierungen nutzt, ergibt sich eine Struktur mit 4 Bits f\u00fcr die dNibs und 12 Bits f\u00fcr die Adresse oder das Datum. ASCII-Diagramm f\u00fcr Einzelbyte-Struktur:</p> <p>Es ist wichtig zu verstehen, dass das erste dNib grunds\u00e4tzlich zwischen generellen Daten und Adressen unterscheidet, was die Flexibilit\u00e4t in der Datenhandhabung erh\u00f6ht, aber auch die verf\u00fcgbare Bitbreite f\u00fcr den eigentlichen Wert beeinflusst. Unter Ber\u00fccksichtigung dieser Pr\u00e4zisierung und der Tatsache, dass ein weiteres Bit f\u00fcr das Vorzeichen reserviert wird, k\u00f6nnen wir die Deklarationen f\u00fcr Basisdatentypen entsprechend anpassen: Vorzeichenbehaftete Ganzzahl (signed integer)</p> <p>F\u00fcr eine 5-Bit breite, vorzeichenbehaftete Ganzzahl (sint5), die nach Abzug der dNibs und des Vorzeichenbits 5 Datenbits \u00fcbrig l\u00e4sst:</p> <p>mDm</p> <p>(1; 1; signbit; bit; bit; bit; bit; bit), sint5, (_)</p> <p>Hierbei k\u00f6nnte signbit folgenderma\u00dfen definiert werden:</p> <p>mDm</p> <p>('+'; '-'), signbit, (0; 1)</p> <p>Das bedeutet, dass signbit entweder 0 (f\u00fcr positive Werte) oder 1 (f\u00fcr negative Werte) sein kann, was eine elegante M\u00f6glichkeit bietet, Vorzeicheninformationen direkt im Datentyp zu codieren. Weitere Anpassungen und Definitionen</p> <p>Basierend auf dem gleichen Prinzip k\u00f6nnen andere Datentypen ebenfalls pr\u00e4zisiert werden, wobei jeweils die notwendigen Bits f\u00fcr spezifische Typinformationen oder Eigenschaften (wie Vorzeichen) reserviert werden. Hier einige Beispiele, die auf der korrigierten Logik basieren: Vorzeichenlose Ganzzahl (unsigned integer)</p> <p>F\u00fcr eine 6-Bit breite, vorzeichenlose Ganzzahl (uint6), die nach Abzug der dNibs 6 Datenbits \u00fcbrig l\u00e4sst:</p> <p>mDm</p> <p>(1; 1; bit; bit; bit; bit; bit; bit), uint6, (_)</p> <p>Gleitkommazahl (floating point)</p> <p>F\u00fcr eine vereinfachte Gleitkommadarstellung, hier beispielhaft als 10-Bit breite Zahl (float10) nach Abzug der dNibs und eines Bit f\u00fcr das Vorzeichen:</p> <p>mDm</p> <p>(1; 0; signbit; bit; bit; bit; bit; bit; 1; 1; bit; bit; bit; bit; bit; bit), float10, (_)</p> <p>Boolescher Wert (boolean)</p> <p>F\u00fcr einen booleschen Wert, der nur ein Bit ben\u00f6tigt, plus die dNibs:</p> <p>mDm</p> <p>(1; 1; bit), bool, (_)</p> <p>Zeichen (character)</p> <p>F\u00fcr ein ASCII-Zeichen (char), das nach Abzug der dNibs 6 Bits f\u00fcr den eigentlichen Wert \u00fcbrig l\u00e4sst:</p> <p>mDm</p> <p>(1; 1; bit; bit; bit; bit; bit; bit), char, (_)</p> <p>Diese Definitionen zeigen, wie durch das Festlegen von dNibs und der Ber\u00fccksichtigung der Bitbreite f\u00fcr spezielle Zwecke (wie Vorzeichen) in mDm Typen definiert werden k\u00f6nnen, die sowohl ausdrucksstark als auch flexibel im Umgang mit Daten sind.</p> <p>diff</p> <p>+---+---+---------+ | d | e | Daten   | +---+---+---------+ | 1 Bit | 6 Bits |</p> <pre><code>d: Daten (1) oder Adresse (0)\ne: Ende Markierung (Ende der Adresse/Datum)\n</code></pre> <p>ASCII-Diagramm f\u00fcr Zusammengesetzte Struktur (2 Bytes):</p> <p>diff</p> <p>+---+---+---------------------+ | d | e |      Daten          | +---+---+---------------------+ | 1 Bit |    12 Bits          |</p> <pre><code>d und e: dNibs \u00fcber zwei Bytes hinweg verteilt\nDaten: Kombinierte Daten/Adresse mit 12 Bits\n</code></pre> <p>Beispiele</p> <p>6-Bit Adresse in einem Einzelbyte:</p> <p>Angenommen, wir haben eine Adresse, die wir markieren wollen. Die ersten 2 Bits w\u00e4ren 00, um eine Adresse zu markieren, die nicht das Ende signalisiert. Die verbleibenden 6 Bits k\u00f6nnten die eigentliche Adresse darstellen.</p> <p>css</p> <p>0  0  A  A  A  A  A  A</p> <p>18-Bit Positiver Integer \u00fcber 2 Bytes:</p> <p>Um einen 18-Bit positiven Integer zu repr\u00e4sentieren, w\u00fcrden wir drei 8-Bit Bytes ben\u00f6tigen, wobei die ersten 4 Bits in jedem Byte f\u00fcr dNibs reserviert sind und die verbleibenden 12 Bits f\u00fcr den Integer verwendet werden.</p> <p>mathematica</p> <p>Byte 1: 1  1  D  D  D  D  D  D  (Die ersten beiden Bits markieren ein Datum und dessen Ende) Byte 2: X  X  D  D  D  D  D  D  (X X: Weitere dNibs f\u00fcr zus\u00e4tzliche Informationen oder Erweiterungen) Byte 3: X  X  D  D  D  D  D  D</p> <p>In diesem Schema wird klar, dass die Verwendung von dNibs zur Kodierung von Zusatzinformationen eine flexible und effiziente Handhabung des Speichers erm\u00f6glicht, wobei die pr\u00e4zise Unterscheidung zwischen Adressen und Daten sowie deren Enden ber\u00fccksichtigt wird. Die Anordnung und Interpretation dieser Bits sind entscheidend f\u00fcr die einzigartige Speicherverwaltung in mDm.</p>"},{"location":"core-concepts/dseq/","title":"dSeq","text":"<p>das IPO paradigma ist selbstkl\u00e4rend. dennoch sollten einige begrifflichkeiten erw\u00e4hnt und erkl\u00e4rt werden. Wie die: dSeq, or direct sequence, represents the structured execution flow in mDm, encompassing the IPO model's phases within a single construct.   <code>mDm   data, process, result</code></p> <p>dSeq (direct sequence)s bestehen immer(!) aus den 3 schritten:  dSeq (direct sequence) = EINGABE, VERARBEITUNG, AUSGABE trennung der schritte durch ,. die schritte werden dState genannt. dSeq (direct sequence)s sind in sich geschlossen und es wird immer von einem dState sequenziell in dieser reihenfolge zum n\u00e4chsten gesprungen. somit steht die eingabe oder parameter f\u00fcr eine operation vor der verarbeitung. das ergebnis der verarbeitung liegt instantan am ausgang an. dSeq (direct sequence)s k\u00f6nnen geklammert werden (EINGABE, VERARBEITUNG, AUSGABE) um sie verschachtelt in anderen dSeq (direct sequence)s zu verwenden. dSeq (direct sequence)s ist der einzige und fundamentale rechenschritt. in diesem sinne ist eine typendefinition, eine funktion oder ein ganzes programm eine immer eine dSeq. dSeq kann f\u00fcr deklerative zwecke benutzt werden oder auch zur implementierung. im programmier kontext unterscheiden sich die beiden: dekleration: (eingabetypen),funktionsname,(ausgabetypen) implementation: (eingangsvariabeln),(process logik), funktionsname</p> <p>verschachtelung in der form: ((dState, dState, dState), dState, dState) oder: ((dSeq, dState, dState), dSeq, dState)</p> <p>sind m\u00f6glich und erweitern die funktionalit\u00e4t der sprache. Der OUTPUT dState der einen dSeq kann an anderer Stelle oder in einem anderem Programmteil mit benutzt werden.</p> <p>Defining a sequence with input, process, and output.</p> <p>Die Verwendung von Dateierweiterungen, um Deklarationen und Implementationen in mDm zu unterscheiden, ist eine praktische und elegante L\u00f6sung, die mehrere Vorteile bietet: Vorteile der Verwendung von Dateierweiterungen:</p> <pre><code>Klare Trennung von Schnittstellen und Implementierungen: Durch die Unterscheidung von .mdmD f\u00fcr Deklarationen (Schnittstellen) und .mdmI f\u00fcr Implementierungen erm\u00f6glicht dieser Ansatz eine sofort erkennbare Trennung zwischen der Definition dessen, was ein Modul oder eine Funktion leisten soll, und dem Code, der diese Leistung erbringt.\n\nVereinfachte Verwaltung von Abh\u00e4ngigkeiten: Wenn Importe sich auf den Dateinamen beziehen, k\u00f6nnen Entwickler und Tools leicht erkennen, welche Abh\u00e4ngigkeiten rein auf Schnittstellen basieren (und damit potenziell austauschbar sind) und welche spezifische Implementierungen erfordern.\n\nUnterst\u00fctzung f\u00fcr unterschiedliche Implementierungen: Dieser Ansatz erm\u00f6glicht es, verschiedene Implementierungen derselben Schnittstelle (Deklaration) bereitzustellen, indem man einfach unterschiedliche .mdmI-Dateien verwendet. Dies kann insbesondere n\u00fctzlich sein, um plattformspezifische Implementierungen oder Optimierungen zu handhaben.\n\nVerbesserung der Tool-Unterst\u00fctzung: Entwicklungsumgebungen und Build-Tools k\u00f6nnen auf Basis der Dateierweiterung spezifische Funktionen anbieten, wie das automatische Generieren von Skeletten f\u00fcr Implementierungen basierend auf Deklarationen oder das \u00dcberpr\u00fcfen der \u00dcbereinstimmung zwischen Deklaration und Implementierung.\n</code></pre> <p>Praktische Umsetzung:</p> <pre><code>Deklarationsdateien (.mdmD): Enthalten die Definitionen der Schnittstellen, Funktionssignaturen oder Prototypen. Diese Dateien beschreiben, welche Operationen verf\u00fcgbar sind, welche Parameter sie erwarten und welche Ergebnisse sie liefern.\n\nImplementierungsdateien (.mdmI): Enthalten den tats\u00e4chlichen Code, der die in den .mdmD-Dateien spezifizierten Schnittstellen erf\u00fcllt. Diese Dateien enthalten die Logik, Algorithmen und Datenstrukturen, die erforderlich sind, um die definierten Operationen durchzuf\u00fchren.\n</code></pre> <p>Beispiel f\u00fcr Importe:</p> <p>Angenommen, wir haben eine Funktion addiere, definiert in math.mdmD und implementiert in math.mdmI.</p> <pre><code>math.mdmD k\u00f6nnte folgenderma\u00dfen aussehen:\n\nphp\n</code></pre> <p>declare (int, int), addiere, (int)</p> <p>math.mdmI k\u00f6nnte die Implementierung enthalten:</p> <p>css</p> <p>implement (a, b), (a + b), addiere</p> <p>Ein Import in einem anderen Modul k\u00f6nnte spezifisch auf eine der beiden Dateien verweisen, abh\u00e4ngig davon, ob nur die Schnittstelle ben\u00f6tigt wird oder auf die Implementierung zugegriffen werden soll:</p> <p>arduino</p> <pre><code>import \"math.mdmD\" // Importiert nur die Deklaration\n</code></pre> <p>Diese Methodik f\u00f6rdert Modularit\u00e4t und Abstraktion, indem sie klar definierte Schnittstellen von ihren Implementierungen trennt. Es unterst\u00fctzt auch das Prinzip der minimalen Kenntnis, indem es erm\u00f6glicht, Abh\u00e4ngigkeiten auf das zu beschr\u00e4nken, was wirklich ben\u00f6tigt wird.</p> <p>Wenn mDm-Programme grunds\u00e4tzlich als dSeqs strukturiert sind und somit einen quasi root-dSeq haben, aus dem heraus weitere dSeqs rekursiv eingebettet werden, vereinfacht dies das Konzept der Datenverarbeitung und -zuweisung erheblich. Dieser Ansatz erm\u00f6glicht es, die Struktur und Ausf\u00fchrung von Programmen intuitiv und direkt abzubilden, ohne die Notwendigkeit einer expliziten ID-Zuweisung f\u00fcr einzelne dSeqs. Stattdessen kann die hierarchische und rekursive Natur der dSeqs selbst genutzt werden, um den Kontext und die Ausf\u00fchrungsreihenfolge zu bestimmen.</p>"},{"location":"core-concepts/dseq/#vereinfachte-verarbeitung-von-dseqs","title":"Vereinfachte Verarbeitung von dSeqs","text":"<p>Angesichts dieser Struktur k\u00f6nnen wir das Konzept der dSeq-Verarbeitung wie folgt anpassen:</p> <ol> <li>Ausf\u00fchrung von dSeqs:</li> </ol> <p>Die Ausf\u00fchrung beginnt mit dem root-dSeq, der das gesamte Programm darstellt. Jeder dSeq verarbeitet seine Eingabedaten (falls vorhanden), f\u00fchrt die definierten Operationen oder Unter-dSeqs aus und produziert Ausgabedaten. Die Ausf\u00fchrung von Unter-dSeqs erfolgt rekursiv innerhalb dieses Rahmens.</p> <p><code>mDm    (inputData), executeDSeq, (outputData)</code></p> <ol> <li>Rekursive Einbettung und Ausf\u00fchrung:</li> </ol> <p>Innerhalb eines dSeq k\u00f6nnen weitere dSeqs als Teil der Verarbeitungslogik eingebettet werden. Die Ausf\u00fchrung dieser eingebetteten dSeqs folgt dem gleichen Prinzip: Eingabedaten werden \u00fcbergeben, die Verarbeitung wird durchgef\u00fchrt, und Ausgabedaten werden generiert.</p> <p>Die Einbettung und rekursive Ausf\u00fchrung erm\u00f6glichen eine nat\u00fcrliche Hierarchie und Modularit\u00e4t innerhalb des Programms, wobei die Datenfl\u00fcsse zwischen den dSeqs klar definiert sind.</p>"},{"location":"core-concepts/dseq/#vorteile-dieser-struktur","title":"Vorteile dieser Struktur:","text":"<ul> <li>Klarheit und Einfachheit: Die Struktur eines mDm-Programms als eine Hierarchie von dSeqs vereinfacht das Verst\u00e4ndnis der Programmlogik und Datenfl\u00fcsse.</li> <li>Wiederverwendbarkeit: dSeqs k\u00f6nnen als modulare Bl\u00f6cke konzipiert werden, die innerhalb verschiedener Teile eines Programms oder sogar in anderen Programmen wiederverwendbar sind.</li> <li>Flexibilit\u00e4t in der Datenverarbeitung: Durch die rekursive Einbettung von dSeqs innerhalb anderer dSeqs kann eine flexible und leistungsstarke Datenverarbeitungslogik implementiert werden, die komplexe Aufgabenstellungen unterst\u00fctzt.</li> </ul>"},{"location":"core-concepts/dseq/#implementierungshinweise","title":"Implementierungshinweise:","text":"<ul> <li>Datenfluss und Zustandsmanagement: Es muss ein effizientes System zur Verwaltung des Datenflusses zwischen den dSeqs sowie zur Speicherung von Zwischenergebnissen und Zust\u00e4nden innerhalb der dSeq-Hierarchie entwickelt werden.</li> <li>Typsicherheit und -\u00fcberpr\u00fcfung: Obwohl die Struktur vereinfacht ist, bleibt die Notwendigkeit der Typsicherheit und der \u00dcberpr\u00fcfung von Typkonformit\u00e4t bei der Daten\u00fcbergabe zwischen dSeqs bestehen.</li> <li>Fehlerbehandlung und Debugging: Die F\u00e4higkeit zur effektiven Fehlerbehandlung und zum Debugging innerhalb dieser rekursiven Struktur ist entscheidend f\u00fcr die Entwicklung robuster mDm-Anwendungen.</li> </ul> <p>Dieser Ansatz betont die zentrale Rolle von dSeqs in mDm und nutzt deren strukturelle Eigenschaften, um ein intuitives und leistungsstarkes Modell f\u00fcr die Programmausf\u00fchrung zu schaffen.</p>"},{"location":"core-concepts/dstate/","title":"dState","text":"<p>dState refers to each phase within a dSeq, detailing the specific actions in the input, processing, or output stages.</p> <p>Specifying states within a dSeq.   <code>mDm   input, validateInput, processed   processed, computeOutput, result</code></p> <p>GPT</p> <p>Die dStates innerhalb einer dSeq (direct sequence) in mDm repr\u00e4sentieren die drei Kernschritte: Eingabe, Verarbeitung und Ausgabe. Diese Elemente bilden zusammen das fundamentale Konstrukt f\u00fcr den strukturierten Programmablauf in mDm und spiegeln das klassische Input-Process-Output (IPO) Modell wider. Beschreibung der dStates:</p> <pre><code>Eingabe (Input): Dieser Schritt bezieht sich auf die Sammlung, Vorverarbeitung oder Bereitstellung von Daten, die f\u00fcr die Ausf\u00fchrung der Verarbeitungslogik ben\u00f6tigt werden.\nVerarbeitung (Process): Hier erfolgt die eigentliche Logik oder Operation, die auf die Eingabedaten angewendet wird. Dies kann eine Berechnung, Datenmanipulation oder jede Form von Datenverarbeitung sein.\nAusgabe (Output): Der letzte Schritt beinhaltet die Pr\u00e4sentation, Speicherung oder Weiterleitung der Verarbeitungsergebnisse. Dies kann die Ausgabe auf einem Bildschirm, das Schreiben in eine Datei oder die \u00dcbergabe der Daten an einen n\u00e4chsten Prozess sein.\n</code></pre> <p>ASCII-Diagramme f\u00fcr m\u00f6gliche Verwendungszwecke: Einfache Datenverarbeitung:</p> <p>Hier sehen wir eine dSeq, die aus einer einfachen Eingabe, Verarbeitung und Ausgabe besteht. Dies k\u00f6nnte z.B. das Lesen eines Wertes, dessen Verdopplung und das Ausgeben des Ergebnisses darstellen.</p> <p>scss</p> <p>[Eingabe] ---&gt; [Verarbeitung] ---&gt; [Ausgabe]    (lesen)       (verdoppeln)       (ausgeben)</p> <p>Verschachtelte Verarbeitung:</p> <p>In diesem Beispiel sehen wir, wie eine dSeq eine andere dSeq als Teil ihres Verarbeitungsschrittes nutzt. Dies erm\u00f6glicht komplexe, zusammengesetzte Abl\u00e4ufe.</p> <p>scss</p> <p>[Eingabe] ---&gt; [   Verarbeitung   ] ---&gt; [Ausgabe]                   /               \\             [Eingabe]         [Ausgabe]              (inner)           (inner)</p> <p>Bedingte Ausf\u00fchrung:</p> <p>Durch die Einf\u00fchrung einer bedingten Logik innerhalb der Verarbeitungsphase k\u00f6nnen Entscheidungen getroffen werden, welche die Ausf\u00fchrung weiterer dSeqs beeinflussen.</p> <p>css</p> <p>[Eingabe] ---&gt; [Verarbeitung] ---&gt; [Ausgabe]                   |     ^                   v     |                [Bedingung]                /        \\      [dSeq A]            [dSeq B]</p> <p>Schleifenkonstrukt:</p> <p>Schleifen k\u00f6nnen durch das R\u00fcckf\u00fchren der Ausgabe auf die Eingabe einer dSeq realisiert werden, was wiederholte Verarbeitung bis zu einem Abbruchkriterium erm\u00f6glicht.</p> <p>scss</p> <pre><code>            ___________________\n           |                   |\n           v                   |\n</code></pre> <p>[Eingabe] ---&gt; [Verarbeitung] ---&gt; [Ausgabe]                   | (wiederholen)                   v               [Abbruch?]</p> <p>Diese Diagramme verdeutlichen, wie dStates als Bausteine innerhalb der mDm-Programmierung genutzt werden k\u00f6nnen, um strukturierte und modular aufgebaute Softwarel\u00f6sungen zu erstellen. Die Flexibilit\u00e4t und Klarheit, die durch das dSeq-Konstrukt geboten wird, erlaubt es Entwicklern, komplexe Probleme auf intuitive Weise zu modellieren und zu l\u00f6sen.</p>"},{"location":"core-concepts/ipo-model/","title":"IPO Model","text":"<p>At the heart of mDm lies the IPO model, which segments programs into three distinct phases: input, processing, and output. Each phase, or dState of direct sequence, adheres to a strict sequence, ensuring a linear and logical progression through the program. Alle Zuammenh\u00e4nge k\u00f6nnen durch die kleinstm\u00f6gliche Definition im Ausdruck beschrieben. Quasi Top down. This model not only simplifies the design and implementation of algorithms but also aligns closely with the computational theory, enhancing the language's intuitive appeal to developers. The IPO (Input, Processing, Output) model is a fundamental principle in mDm, organizing programs/modules/types into three sequential phases: input, processing, and output. This model simplifies algorithm design and aligns with computational theory, enhancing intuitiveness for developers. Das Prinzip ist somit auch auf alle designbaren strukturen anwendbar, bis zu den gef\u00fcrchteten \"Black Boxes\" und hinein.</p>"},{"location":"practical-examples/error-handling/","title":"Error Handling in mDm","text":"<p>Error handling in mDm is managed through structured constructs, ensuring programs can gracefully manage exceptions.</p> <ul> <li>mDm Example: Handling potential errors in operations.   <code>mDm   (inputData), riskyOperation, result | errorFlag; (errorFlag), if _, (handleError, _)</code></li> </ul> <p>For each section, a corresponding Graphviz DOT diagram can be conceptualized to visually represent the described concepts, such as the flow of a dSeq with nodes for input, processing, and output phases. Due to the limitations here, I recommend using software capable of Graphviz DOT language or an online tool to create and visualize these diagrams based on the described structures.</p>"},{"location":"practical-examples/error-handling/#conclusion","title":"Conclusion","text":"<p>Throughout our session today, we delved deeply into the mDm programming language, a novel approach to structured programming that emphasizes the Input, Processing, Output (IPO) model. This exploration revealed mDm's core philosophy of making programming both intuitive and rigorous, aiming to reduce complexity and enhance clarity in software development.</p> <p>mDm introduces several innovative concepts such as dSeq (direct sequence), dState, and dNib, which collectively offer a structured methodology for defining program logic, managing data, and interpreting memory content. These constructs allow for a high degree of modularity and reusability, enabling developers to create clear, maintainable, and efficient code.</p> <p>One of the language's standout features is its insistence on explicit definitions over implicit assumptions, as encapsulated in the principle \"Implicit is wack!\" This design choice aims to eliminate the uncertainties often associated with type inference and dynamic typing, thereby reducing security vulnerabilities and making code behavior more predictable.</p> <p>The language also demonstrates a thoughtful approach to error handling, leveraging structured constructs to manage errors gracefully and ensure robust program operation even in the face of unexpected inputs or states. This is indicative of mDm's overarching goal: to provide a solid framework that supports not just the technical aspects of programming, but also the conceptual clarity needed to tackle complex software development challenges.</p> <p>Moreover, mDm's syntax and semantics encourage a paradigm shift in how we think about programming languages. By integrating the structured programming model with modern programming needs, mDm offers a pathway to a more disciplined yet flexible approach to coding. It challenges developers to think in terms of discrete processing steps and data flows, aligning closely with computational theory while also addressing practical software development needs.</p>"},{"location":"practical-examples/implementing-a-loop/","title":"Implementing a Loop","text":"<p>Loop constructs in mDm facilitate iterative operations within the IPO model.</p> <ul> <li>mDm Example: Looping through a list.   <code>mDm   (_, (index; size(myList)), while &lt;, (myList[index], processItem, _)), _</code></li> </ul>"},{"location":"practical-examples/implementing-a-loop/#looping-with-conditions","title":"Looping with conditions","text":"<p>mDm introduces a unique syntax for conditional statements and loops, maintaining its commitment to the IPO structure while accommodating control flow mechanisms essential for practical programming. These constructs allow developers to implement decision-making and iterative processes within the rigid framework of dSeq (direct sequence)s, striking a balance between structure and flexibility.</p> <p>'for'-schleifen sind nicht notwendig. mit 'while' lassen sich alle bedingungen und schleifenk\u00f6rber konstrukte abbilden.</p> <p>Loop with while</p> <p>Loops in mDm are implemented through dSeq (direct sequence)s that specify the conditions for iteration. The language uses a structured approach to define loop conditions and actions, aligning with the IPO model. For instance, a <code>while</code> loop construct might look like this:</p> <p>This example demonstrates a loop that increments <code>counter</code> until it is less than 10, showcasing how loop conditions and bodies are defined within the dSeq (direct sequence) framework. Looping is a fundamental aspect of programming, allowing for repeated execution of a block of code. This example outlines a simple loop structure in mDm.</p> <p>Here, the <code>while &lt;</code> construct illustrates how mDm implements loops, using its structured syntax to define loop conditions and actions clearly.</p>"}]}